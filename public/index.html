<script>
  const CLOUD = "dvqpndvej"; // your Cloudinary cloud

  // --- tiny helpers ---
  const $ = (s) => document.querySelector(s);
  const row = $("#row");
  const msg = $("#msg");

  const deliveryUrl = (publicId) =>
    `https://res.cloudinary.com/${CLOUD}/image/upload/${publicId}.jpg`;

  const headOK = (url) =>
    fetch(url, { method: "HEAD" }).then(r => r.ok).catch(() => false);

  const addCard = (url, label) => {
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <img src="${url}" alt="" />
      <div class="cap">${label || url.replace(/^https?:\/\/[^/]+\/image\/upload\//,'')}</div>
      <a class="open" href="${url}" target="_blank" rel="noopener">Open original</a>
    `;
    row.appendChild(card);
  };

  // Find the main photo by probing recent dates (same logic you had before)
  async function findExistingPublicId(shortId) {
    // Try both casings
    const ids = [shortId, (shortId||"").toUpperCase(), (shortId||"").toLowerCase()]
      .filter((v,i,a)=>v && a.indexOf(v)===i);

    // We only look in the two venues you use
    const venues = ["chiefs-luau","ka-moana-luau"];
    // Look back ~90 days; favor Month-in-path FIRST, then without
    const MONTHS = ["January","February","March","April","May","June","July","August","September","October","November","December"];
    const start = new Date();
    for (let d=0; d<90; d++){
      const dt = new Date(start); dt.setDate(start.getDate()-d);
      const Y = dt.getFullYear();
      const Mtxt = MONTHS[dt.getMonth()];
      const mdY = ("0"+(dt.getMonth()+1)).slice(-2)+"."+("0"+dt.getDate()).slice(-2)+"."+Y;
      for (const v of venues){
        for (const id of ids){
          const withMonth = `${v}/${Y}/${Mtxt}/${mdY}/${id}`;
          if (await headOK(deliveryUrl(withMonth))) return withMonth;
          const noMonth = `${v}/${Y}/${mdY}/${id}`;
          if (await headOK(deliveryUrl(noMonth))) return noMonth;
        }
      }
    }
    return null;
  }

  function plusMinusOne(file){
    const digits = (file.match(/(\d+)$/)||[])[1]||"";
    const prefix = file.slice(0, file.length - digits.length);
    const n = parseInt(digits||"0", 10);
    return { prev: `${prefix}${n-1}`, next: `${prefix}${n+1}` };
  }

  $("#goBtn").onclick = async () => {
    row.innerHTML = "";
    msg.textContent = "";
    const raw = ($("#photoId").value||"").trim();
    if (!raw){ msg.textContent = "Please enter your Photo ID."; return; }

    // Accept either a short ID (CH0928251007) or a full public_id path
    const isPublicIdPath = raw.includes("/");
    let publicId = null;

    if (isPublicIdPath) {
      // If user pasted a full path, verify it exists
      const url = deliveryUrl(raw);
      if (await headOK(url)) publicId = raw;
    } else {
      // Short ID: probe to find the real foldered public_id
      msg.textContent = "Searching across recent dates…";
      publicId = await findExistingPublicId(raw);
    }

    if (!publicId){
      msg.textContent = "Sorry, we couldn’t find that ID in the last 90 days.";
      return;
    }

    // 1) Show the main photo
    const mainUrl = deliveryUrl(publicId);
    addCard(mainUrl, "This photo");

    // 2) Neighbors from the SAME folder as the main
    const folder = publicId.replace(/\/[^/]+$/, "");
    const file   = publicId.split("/").pop();
    const { prev, next } = plusMinusOne(file);

    // Try both “month-in-path” and “no-month” variants for neighbors,
    // in case your uploads mix styles between days.
    const monthMatcher = /\/(January|February|March|April|May|June|July|August|September|October|November|December)\//;
    const hasMonth = monthMatcher.test(folder);
    const folderNoMonth = hasMonth ? folder.replace(/\/(January|February|March|April|May|June|July|August|September|October|November|December)\/[^/]+/, "") : folder;

    const neighborPublicIds = [
      `${folder}/${prev}`,
      `${folder}/${next}`,
      `${folderNoMonth}/${prev}`,
      `${folderNoMonth}/${next}`,
    ].filter((v,i,a)=>a.indexOf(v)===i);

    const checks = await Promise.all(neighborPublicIds.map(pid => headOK(deliveryUrl(pid)).then(ok => ({ok, pid}))));
    checks.filter(c=>c.ok).forEach(c => addCard(deliveryUrl(c.pid)));

    msg.textContent = "Done.";
  };
</script>
